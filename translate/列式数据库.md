*翻译自[Column-oriented DBMS](https://en.wikipedia.org/wiki/Column-oriented_DBMS)*

# Column-oriented DBMS

面向列的DBMS（或列式数据库管理系统）是按列而不是按行存储数据表的数据库管理系统。在关系型数据库管理系统领域，实际使用列式存储和行式存储并没有什么区别。列和行数据库都可以使用传统的数据库查询语言（如sql）来加载数据并执行查询。列和行数据库都可以成为系统的支柱，为通用extract-transform-load（ETL）和数据可视化系统提供数据。然而，将数据存储在列中而不是行中，数据可可以更准确的访问到需要应答某个查询的数据，而不是扫描并丢弃行中不需要的数据。查询性能由此而提高，尤其是在非常大的数据集中。


## 描述

### 背景

关系型数据库管理系统提供的数据描述了一个包含列和行的二维表。比如说一个数据库里有这样一张表：

RowId | EmpId | Lastname | Firstname | Salary
--- | --- | --- | --- | ---
001 | 10 | Smith | Joe | 40000
002 | 12 | Jones | Mary | 50000
003 | 11 | Johnson | Cathy | 44000
004 | 22 | Jones | Bob | 55000

这个简单的表包含了一个员工的标识（EmpId）、名称字段（Lastname和Firstname）和工资。这个二维表的格式是一种抽象，实际的实现中硬件存储会要求数据被序列化成某一种格式。

涉及到硬盘的最昂贵的操作是[寻址](https://en.wikipedia.org/wiki/Seek_delay)，为了改善整体的性能，应该以可以最小化寻址次数的方式存储关联数据。这就是人们熟知的[Locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference)，基本概念出现在不同的上下文环境中。硬盘以一些列固定大小的块组织起来，通常可以存放表里若干行数据。通过组织表的数据，使行适应这些块，并将相邻的行分组到连续的块中。在很多情况下，需要读取或寻找的块数和寻址的次数一起被最小化了（这句没懂...）。


### 面向行的系统

存储一张表的通用做法是序列化每一行数据，就像这样：

```
001:10,Smith,Joe,40000;
002:12,Jones,Mary,50000;
003:11,Johnson,Cathy,44000;
004:22,Jones,Bob,55000;
```

当数据插入表中时，它被分配一个内部的id，这个`rowid`字段在系统内部被用来关联数据。在这种情况下，记录具有独立于用户指定的empid的顺序rowid。这个例子当中，DBMS用短整型（short integer）存放rowid，实际使用会用更大的数字，比如64位、128位。

基于行的系统被设计的用尽可能少的操作，就可以有效的返回整行或记录数据。这适合一些常见的用例，比如系统尝试获取某一特定对象的信息，像是名片系统里用户的联系信息，或是线上购物系统里的商品信息。通过将这些数据和其它相邻数据存放到一个单独的块中，系统可以很快的用最少的操作获取到记录。

与一小部分特定的数据相反，行式系统在整张表上做集合范围（set-wide）的操作往往很低效。例如在这个例子里，要想找到工资在40000到50000之间的全部记录，DBMS必须完全遍历整个表来寻找匹配的记录。在上述的表格里数据可能在一个单独的块中，有上百行记录的表就不会这样，这时候就需要用多次磁盘操作来获取数据，并检查它。

为了提高这些操作的性能（这是很常见的，并且也是DBMS的关键点），大多数DBMS支持使用索引，将一列里所有的数据和可以指引到原始表的rowid存放到一起。salary列的索引看起来是这个样子的：

```
001:40000;
003:44000;
002:50000;
004:55000;
```

由于它们只存储了一小片数据，而不是整行，索引总的来说要比主表要小。扫描这个小数据集减少了磁盘的操作。如果索引被重度使用，它可以显著的减少常见操作的时间。然而维护索引增加了系统的开销，尤其是新数据写入到数据库的时候，记录不仅要存放到主表，任何附加的索引都要同步更新。

在某一列或某些列的数据库索引通常都是按列存储，因此范围查找的操作（比如上面说的“获取工资在40000到50000的全部记录”）会非常快。

一些行数据库被设计的完全填充到内存中，成为一个[内存数据库](https://en.wikipedia.org/wiki/In-memory_database)，这些系统不依赖磁盘操作，而且对于整个数据集有相等的访问时间。这样就不需要索引了，因为在典型的聚合场景中，扫描原始数据和整个索引所需要的操作数量是相同的。这样的系统可能更简单更小，但是只能管理能放进内存的数据库。


### 面向列的系统

面向列的数据库将一列的全部数据序列化到一起，然后是另外一列，以此类推。例如我们的样例表，数据存储的风格是这样的：

```
10:001,12:002,11:003,22:004;
Smith:001,Jones:002,Johnson:003,Jones:004;
Joe:001,Mary:002,Cathy:003,Bob:004;
40000:001,50000:002,44000:003,55000:004;
```

这个布局，列更像是行式系统里的索引结构，这会让人们误以为：列式存储“不就是”每一列都带有索引的行式存储吗。
